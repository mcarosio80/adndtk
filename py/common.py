import sqlite3
from sqlite3 import Error
from sys import argv
#from datetime import datetime
import os
import re
from datetime import datetime

################################
def connect_db(db_file):
    conn = None
    try:
        conn = sqlite3.connect(db_file)
    except Error as e:
        print(e)

    return conn

################################
def clean_string(token):
    t = token.lower()
    return t.replace(' ', '_').replace('\'', '').replace('-', '_').replace('+', '_or_more').replace(',', '').replace(')', '').replace('(', '').replace('.', '').replace('/', '_')

################################
def fetch_key_value_pairs(conn, key, value, table, sort = False):
    cur = conn.cursor()
    order_clause = f" order by {key}"
    query = "SELECT {}, {} FROM {}{};".format(key, value, table, order_clause)
    cur.execute(query)

    rows = cur.fetchall()

    lines = list()
    for row in rows:
        lines.append(f"{clean_string(row[0])} = {row[1]}")
    return lines


################################
def print_help(exeName):
    print (f'Usage: {exeName} -d <db_file> -j <json_config> -o <output_header> -n <lib-namespace:module-namespace>')

################################
def indent(indentationLevel):
    if indentationLevel == 0:
        return ""
    return '\t' * indentationLevel

################################
def fetch_tables(conn, tableList):
    cur = conn.cursor()
    cur.execute(f"select lower(name) as name from sqlite_master where type = 'table';")
    rows = cur.fetchall()

    tables = list()
    for row in rows:
        if row[0] in tableList:
            tables.append(row[0])
    return tables

################################
def to_ctype(varName, sqlType):
    cType = sqlType
    if sqlType == "INTEGER":
        cType = "int"
    elif sqlType == "INT":
        cType = "int"
    elif sqlType == "FLOAT":
        cType = "double"
    else:
        res = re.search(r"CHAR\((\d+)\)", sqlType)
        if res:
            if int(res.group(1)) == 1:
                cType = "char"
            else:
                cType = "std::string"
        # if res:
        #     cType = "char"
        #     if int(res.group(1)) > 1:
        #         varName = f"{varName}[{res.group(1)}]"
    
    return cType, varName

################################
def fetch_table_info(conn, tableName):
    cur = conn.cursor()
    cur.execute(f"pragma table_info({tableName});")
    rows = cur.fetchall()

    info = list()
    for row in rows:
        dataType, identifier = to_ctype(row[1].lower(), row[2])
        t = (tableName, row[0], identifier, dataType, row[3], row[4], row[5])
        info.append(t)
    return info


def write_footer(outFile, headerFile):
    headerName = os.path.basename(headerFile)
    includeGuard = headerName.replace('.', '_').upper()
    outFile.write(f'#endif // {includeGuard}\n')
    
################################
def open_namespace(outFile, namespaces):
    indentLevel = 0
    for ns in namespaces:
        outFile.write(f'{indent(indentLevel)}namespace {ns}\n')
        outFile.write(f"{indent(indentLevel)}")
        outFile.write("{\n")
        indentLevel += 1
    return indentLevel

################################
def close_namespace(outFile, namespaces, indentLevel):
    for ns in namespaces:
        indentLevel -= 1
        outFile.write(f"{indent(indentLevel)}")
        outFile.write("}\n")

################################
def write_heading(outFile, headerFile, version):
    now = datetime.now()
    dateTime = now.strftime("%Y-%m-%d, %H:%M:%S")
    headerName = os.path.basename(headerFile)
    
    #outFile.write(f'#pragma once\n\n')
    includeGuard = headerName.replace('.', '_').upper()
    outFile.write(f'#ifndef {includeGuard}\n')
    outFile.write(f'#define {includeGuard}\n\n')

    outFile.write(f'// AD&D Toolkit version {version}\n')
    outFile.write('// Autogenerated header file, do not modify!!\n')
    outFile.write(f'// Header file: {headerName}\n')
    outFile.write(f'// Last modified: {dateTime}\n\n')

################################
def read_dictionary_field(dictData, fieldName, defaultValue):
    return dictData[fieldName] if fieldName in dictData.keys() else defaultValue

################################
def write_csv_caption(outFile, fieldsData, useApices = True, separator = ','):
    firstItem = True
    for fieldValue in fieldsData.keys():
        if firstItem:
            firstItem = False
        else:
            outFile.write(f'{separator}')
        
        if useApices:
            outFile.write(f'"{fieldValue}"')
        else:
            outFile.write(f'{fieldValue}')
    outFile.write('\n')

################################
def write_csv_row(outFile, fieldsData, useApices = True, separator = ','):
    firstItem = True
    for fieldValue in fieldsData.keys():
        if firstItem:
            firstItem = False
        else:
            outFile.write(f'{separator}')

        if useApices:
            outFile.write(f'"{fieldsData[fieldValue]}"')
        else:
            outFile.write(f'{fieldsData[fieldValue]}')
    outFile.write('\n')