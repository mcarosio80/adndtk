import sys
import sqlite3
from sqlite3 import Error
import json
import getopt
from sys import argv
from datetime import datetime
import os

################################
def connect_db(db_file):
    conn = None
    try:
        conn = sqlite3.connect(db_file)
    except Error as e:
        print(e)

    return conn

################################
def clean_string(token):

    token = token.lower().replace('+', '_or_more')

    #for ch in ['.', ',', '', '(', ')', '', '', '\'']:
    #    if ch in token:
    #        token = token.replace(ch, '')
    #for ch in [' ', '-', '/']:
    #    if ch in token:
    #        token = token.replace(ch, '_')
    #        
    return token.lower().replace(' ', '_').replace('\'', '').replace('-', '_').replace('+', '_or_more').replace(',', '').replace(')', '').replace('(', '').replace('.', '').replace('/', '_')
    #return token.lower().replace('[ -]', '_').replace('+', '_or_more').replace('[,)\']', '')

################################
def fetch_enum_values(conn, key, value, table):
    cur = conn.cursor()
    enumKey = clean_string(key)
    #cur.execute(f"SELECT {key} || ' = ' || CAST({value} AS VARCHAR) FROM {table};")
    cur.execute(f"SELECT {key}, CAST({value} AS VARCHAR) FROM {table};")

    rows = cur.fetchall()

    lines = list()
    for row in rows:
        lines.append(f"{clean_string(row[0])} = {row[1]}")
    return lines

################################
def print_enum(lines, enumName, outFile, indentationLevel, isClass = True):
    numLines = len(lines)
    countEnums = 1
    if len(lines) > 0:
        outFile.write(f"{indent(indentationLevel)}")
        if isClass:
            outFile.write(f"enum class {enumName}\n")
        else:
            outFile.write(f"enum {enumName}\n")
            
        outFile.write(f"{indent(indentationLevel)}")
        outFile.write("{\n")

        for line in lines:
            outFile.write(f"{indent(indentationLevel+1)}")
            if countEnums < numLines:
                outFile.write(f"{line},\n")
            else:
                outFile.write(f"{line}\n")
            countEnums += 1

        outFile.write(f"{indent(indentationLevel)}")
        outFile.write("};\n")

def print_help(exeName):
    print (f'Usage: {exeName} -d <db_file> -j <json_config> -o <output_header> -n <lib-namespace:module-namespace>')

def indent(indentationLevel):
    if indentationLevel == 0:
        return ""
    return '\t' * indentationLevel

def main():
    if len(sys.argv) < 2:
        print_help(sys.argv[0])
        sys.exit()

    dbPath = ""
    jsonConfig = ""
    headerFile = ""
    namespaces = list()
    version = ""
    
    opts, args = getopt.getopt(sys.argv[1:],"h:d:j:o:n:v:",["help","database=","json=","output=","namespace=","version="])
    for opt, arg in opts:
        if opt == '-h':
            print_help(sys.argv[0])
            sys.exit()
        elif opt in ("-d", "--database"):
            dbPath = arg
        elif opt in ("-j", "--json"):
            jsonConfig = arg
        elif opt in ("-o", "--output"):
            headerFile = arg
        elif opt in ("-n", "--namespace"):
            namespaces = arg.split(':')
        elif opt in ("-v", "--version"):
            version = arg
    
    cfg = open(jsonConfig)
    data = json.load(cfg)
     
    #open database connection
    conn = connect_db(dbPath)
    if conn is None:
        return 1

    now = datetime.now()
    dateTime = now.strftime("%Y-%m-%d, %H:%M:%S")
    
    with open(headerFile, 'w') as outFile:
        outFile.write(f'#pragma once\n\n')
        outFile.write(f'// AD&D Toolkit version {version}\n')
        outFile.write('// Autogenerated header file, do not modify!!\n')
        outFile.write(f'// Header file: {os.path.basename(headerFile)}\n')
        outFile.write(f'// Last modified: {dateTime}\n\n')
    
        indentation = 0
        for ns in namespaces:
            outFile.write(f'{indent(indentation)}namespace {ns}\n')
            outFile.write(f"{indent(indentation)}")
            outFile.write("{\n")
            indentation += 1

        firstEnum = True
        for d in data:
            tableName = d['table']
            keyColumn = d['key']
            valueColumn = d['value']
            enumName = clean_string(tableName)
    
            if firstEnum:
                firstEnum = False
            else:
                outFile.write("\n")

            lines = fetch_enum_values(conn, keyColumn, valueColumn, tableName)
            print_enum(lines, enumName, outFile, indentation)

        for ns in namespaces:
            indentation -= 1
            outFile.write(f"{indent(indentation)}")
            outFile.write("}\n")
    
    cfg.close()

###############################################
if __name__ == "__main__":    
    main()